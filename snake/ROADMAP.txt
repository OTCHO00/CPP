================================================================================
                    ROADMAP D'APPRENTISSAGE - PROJET SNAKE C++
================================================================================

Cette roadmap t'explique ce que tu dois comprendre et apprendre pour chaque 
fichier. Pas de code √† copier-coller, juste des concepts √† ma√Ætriser !

================================================================================
1. FICHIER: utils.h
================================================================================

CONCEPTS √Ä COMPRENDRE:
---------------------
- #ifndef / #define / #endif : Ce sont des "include guards" (garde d'inclusion)
  ‚Üí Pourquoi c'est important ? √áa √©vite d'inclure le m√™me fichier plusieurs fois
  ‚Üí Alternative moderne : #pragma once (plus simple, mais moins portable)
  
- constexpr : Constante √©valu√©e √† la compilation
  ‚Üí Diff√©rence avec const ? constexpr = valeur connue √† la compilation
  ‚Üí Pourquoi utiliser constexpr ici ? Performance et s√©curit√© de type
  
- Namespace : Organisation du code
  ‚Üí Tu pourrais mettre tes constantes dans un namespace (ex: namespace Config)
  ‚Üí Pourquoi ? √âvite les conflits de noms avec d'autres biblioth√®ques

CHOSES √Ä FAIRE:
---------------
1. Comprendre pourquoi on s√©pare les constantes dans un fichier s√©par√©
2. D√©cider si tu veux utiliser #pragma once ou #ifndef/#define
3. Peut-√™tre cr√©er un namespace pour organiser tes constantes
4. Nommer tes constantes de mani√®re claire (WIDTH/HEIGHT plut√¥t que LARGEUR/HAUTEUR ?)

RESSOURCES √Ä CHERCHER:
----------------------
- "C++ include guards vs pragma once"
- "C++ constexpr vs const"
- "C++ namespace tutorial"

================================================================================
2. FICHIER: snake.h / snake.cpp
================================================================================

CONCEPTS √Ä COMPRENDRE:
---------------------
- Forward declaration : D√©clarer une classe sans l'inclure compl√®tement
  ‚Üí Pourquoi ? Acc√©l√®re la compilation, √©vite les d√©pendances circulaires
  ‚Üí Quand l'utiliser ? Quand tu as juste besoin de savoir qu'une classe existe
  
- enum class : Enum√©ration moderne C++11
  ‚Üí Diff√©rence avec enum classique ? Plus s√ªr, √©vite les conversions implicites
  ‚Üí Pourquoi l'utiliser pour Direction ? Plus propre qu'un int ou string
  
- std::vector : Conteneur dynamique
  ‚Üí Diff√©rence avec array ? Taille variable
  ‚Üí M√©thodes importantes : push_back(), pop_back(), front(), back(), size()
  
- const correctness : Marquer les m√©thodes qui ne modifient pas l'objet
  ‚Üí Pourquoi ? S√©curit√©, permet l'optimisation, meilleure API
  ‚Üí Exemple : getHead() const ‚Üí cette m√©thode ne modifie pas le Snake
  
- R√©f√©rences (const Segment&) : Passer par r√©f√©rence sans copier
  ‚Üí Diff√©rence avec pointeur ? Plus s√ªr, syntaxe plus simple
  ‚Üí Quand utiliser & vs * ? R√©f√©rence = toujours valide, pointeur = peut √™tre null

CHOSES √Ä FAIRE:
---------------
1. Cr√©er un enum class Direction avec UP, DOWN, LEFT, RIGHT
2. Cr√©er une structure Segment pour repr√©senter un segment (x, y)
3. Stocker le corps du serpent dans un std::vector<Segment>
4. Impl√©menter setDirection() : changer la direction (emp√™cher retour en arri√®re)
5. Impl√©menter update() : d√©placer le serpent (ajouter nouvelle t√™te, retirer queue)
6. Impl√©menter grow() : agrandir le serpent quand il mange
7. Impl√©menter checkFoodCollision() : v√©rifier si t√™te == position nourriture
8. Impl√©menter checkWallCollision() : v√©rifier si t√™te sort de l'√©cran
9. Impl√©menter checkSelfCollision() : v√©rifier si t√™te touche le corps
10. Impl√©menter draw() : dessiner chaque segment avec SFML

QUESTIONS √Ä TE POSER:
---------------------
- Comment emp√™cher le serpent de revenir en arri√®re directement ?
- Comment calculer la nouvelle position de la t√™te selon la direction ?
- Comment faire grandir le serpent ? (indice : ne pas retirer la queue)
- Comment aligner le serpent sur une grille (multiples de CELL_SIZE) ?

RESSOURCES √Ä CHERCHER:
----------------------
- "C++ enum class tutorial"
- "C++ std::vector methods"
- "C++ const correctness"
- "C++ references vs pointers"
- "SFML draw rectangle tutorial"

================================================================================
3. FICHIER: food.h / food.cpp
================================================================================

CONCEPTS √Ä COMPRENDRE:
---------------------
- std::random_device / std::mt19937 : G√©n√©rateurs de nombres al√©atoires modernes
  ‚Üí Pourquoi pas rand() ? Plus s√ªr, meilleure distribution, thread-safe
  ‚Üí std::random_device = source d'entropie (vraie al√©a)
  ‚Üí std::mt19937 = algorithme Mersenne Twister (tr√®s bon)
  
- std::uniform_int_distribution : Distribution uniforme d'entiers
  ‚Üí Pourquoi ? Garantit une distribution √©quitable entre min et max
  
- static dans une fonction : Variable partag√©e entre tous les appels
  ‚Üí Pourquoi utiliser static pour rd et gen ? √âvite de recr√©er le g√©n√©rateur
  ‚Üí Attention : static = une seule instance pour toute la dur√©e du programme
  
- Alignement sur grille : S'assurer que la nourriture est align√©e avec le serpent
  ‚Üí Pourquoi ? Le serpent se d√©place par CELL_SIZE, la nourriture doit √™tre align√©e
  ‚Üí Comment ? G√©n√©rer un nombre de cellules, puis multiplier par CELL_SIZE

CHOSES √Ä FAIRE:
---------------
1. Cr√©er getters pour x et y (getX(), getY()) - marquer const
2. Impl√©menter randomizePosition() : g√©n√©rer position al√©atoire align√©e sur grille
3. Impl√©menter respawn() : r√©g√©n√©rer la nourriture (appelle randomizePosition)
4. Impl√©menter draw() : dessiner la nourriture avec SFML (CircleShape par exemple)
5. S'assurer que la position est toujours un multiple de CELL_SIZE

QUESTIONS √Ä TE POSER:
---------------------
- Comment g√©n√©rer un nombre al√©atoire entre 0 et N en C++ moderne ?
- Comment s'assurer que la nourriture n'appara√Æt pas sur le serpent ?
- Quelle forme utiliser pour la nourriture ? (cercle, carr√©, etc.)

RESSOURCES √Ä CHERCHER:
----------------------
- "C++11 random number generation"
- "C++ std::uniform_int_distribution"
- "C++ static variable in function"
- "SFML CircleShape tutorial"

================================================================================
4. FICHIER: game.h / game.cpp
================================================================================

CONCEPTS √Ä COMPRENDRE:
---------------------
- RAII (Resource Acquisition Is Initialization) : Principe fondamental C++
  ‚Üí L'id√©e : Acqu√©rir les ressources dans le constructeur, lib√©rer dans le destructeur
  ‚Üí Pourquoi ? √âvite les fuites m√©moire, gestion automatique
  
- std::unique_ptr : Pointeur intelligent qui poss√®de l'objet
  ‚Üí Pourquoi pas new/delete ? Gestion automatique de la m√©moire
  ‚Üí Quand l'objet est d√©truit, unique_ptr lib√®re automatiquement la m√©moire
  ‚Üí std::make_unique() : Fonction moderne pour cr√©er un unique_ptr
  
- Fixed timestep : Boucle de jeu avec pas de temps fixe
  ‚Üí Pourquoi ? Physique stable, ind√©pendant du framerate
  ‚Üí Comment √ßa marche ? Accumulateur de temps, update plusieurs fois si n√©cessaire
  
- Forward declarations : D√©clarer Snake et Food sans les inclure dans le header
  ‚Üí Pourquoi ? Acc√©l√®re la compilation, √©vite d√©pendances circulaires
  ‚Üí Dans le .cpp, tu incluras les headers complets
  
- delete pour constructeur de copie : Emp√™cher la copie d'un objet
  ‚Üí Pourquoi ? Game ne devrait pas √™tre copiable (une seule instance)
  ‚Üí Game(const Game&) = delete; emp√™che la copie

CHOSES √Ä FAIRE:
---------------
1. Utiliser std::unique_ptr<sf::RenderWindow> au lieu de sf::Window*
2. Utiliser std::unique_ptr<Snake> et std::unique_ptr<Food>
3. Impl√©menter le constructeur : cr√©er la fen√™tre, initialiser snake et food
4. Impl√©menter run() : boucle principale du jeu
   - Calculer deltaTime avec sf::Clock
   - G√©rer les √©v√©nements (handleEvents)
   - Update avec fixed timestep (accumulateur)
   - Rendu (render)
5. Impl√©menter handleEvents() : 
   - D√©tecter fermeture de fen√™tre (sf::Event::Closed)
   - D√©tecter touches clavier (sf::Event::KeyPressed)
   - Changer direction du serpent selon les fl√®ches
6. Impl√©menter update() :
   - Mettre √† jour le serpent
   - V√©rifier collision avec nourriture ‚Üí grandir + respawn
   - V√©rifier collisions murs/corps ‚Üí game over
7. Impl√©menter render() :
   - window->clear() pour effacer l'√©cran
   - Dessiner nourriture et serpent
   - window->display() pour afficher

QUESTIONS √Ä TE POSER:
---------------------
- Pourquoi utiliser RenderWindow au lieu de Window ? (pour pouvoir dessiner)
- Comment fonctionne le fixed timestep ? (accumulateur de temps)
- Comment d√©tecter les touches clavier avec SFML ?
- Comment organiser la boucle de jeu ? (events ‚Üí update ‚Üí render)

RESSOURCES √Ä CHERCHER:
----------------------
- "C++ RAII principle"
- "C++ unique_ptr tutorial"
- "C++ smart pointers"
- "Game loop fixed timestep"
- "SFML event handling"
- "SFML RenderWindow tutorial"

================================================================================
5. FICHIER: main.cpp
================================================================================

CONCEPTS √Ä COMPRENDRE:
---------------------
- Point d'entr√©e : main() est la fonction appel√©e au d√©marrage
  ‚Üí Toujours retourne int (0 = succ√®s, autre = erreur)
  
- Gestion d'erreurs : Que faire si Game() √©choue ?
  ‚Üí Pour l'instant, on peut laisser simple, mais r√©fl√©chis-y
  
- using namespace std : √Ä √©viter dans les headers
  ‚Üí Pourquoi ? Pollue l'espace de noms global
  ‚Üí Dans main.cpp, c'est moins grave, mais pas id√©al

CHOSES √Ä FAIRE:
---------------
1. Cr√©er une instance de Game
2. Appeler game.run()
3. Retourner 0 pour indiquer succ√®s
4. (Optionnel) G√©rer les erreurs si Game() √©choue

QUESTIONS √Ä TE POSER:
---------------------
- Faut-il g√©rer les erreurs ici ? Comment ?
- Comment compiler et lancer le programme ?

RESSOURCES √Ä CHERCHER:
----------------------
- "C++ main function"
- "C++ error handling"

================================================================================
6. ARCHITECTURE G√âN√âRALE
================================================================================

PRINCIPES √Ä COMPRENDRE:
-----------------------
1. S√âPARATION HEADER/IMPL√âMENTATION :
   - .h = d√©clarations (interfaces)
   - .cpp = impl√©mentations (code)
   - Pourquoi ? Compilation plus rapide, meilleure organisation

2. ENCAPSULATION :
   - private = membres internes, pas accessibles de l'ext√©rieur
   - public = interface publique, ce que les autres classes peuvent utiliser
   - Pourquoi ? Prot√®ge les donn√©es, facilite la maintenance

3. CONST CORRECTNESS :
   - Marquer const les m√©thodes qui ne modifient pas l'objet
   - Marquer const les param√®tres qu'on ne modifie pas
   - Pourquoi ? S√©curit√©, optimisation, meilleure API

4. GESTION M√âMOIRE :
   - √âviter new/delete manuels
   - Utiliser smart pointers (unique_ptr, shared_ptr)
   - Pourquoi ? √âvite les fuites m√©moire, plus s√ªr

5. FORWARD DECLARATIONS :
   - Dans les headers, d√©clarer sans inclure quand possible
   - Inclure les headers complets dans les .cpp
   - Pourquoi ? Compilation plus rapide

QUESTIONS √Ä TE POSER SUR L'ARCHITECTURE:
----------------------------------------
- Pourquoi s√©parer Game, Snake, Food en classes diff√©rentes ?
- Comment ces classes communiquent-elles entre elles ?
- Quelle est la responsabilit√© de chaque classe ?
- Comment am√©liorer cette architecture ? (score, menu, etc.)

================================================================================
7. COMPILATION
================================================================================

CONCEPTS √Ä COMPRENDRE:
---------------------
- Compilateur C++ : g++ ou clang++
- Flags importants :
  - -std=c++17 (ou c++11, c++14) : version du standard C++
  - -Wall -Wextra : activer tous les warnings
  - -Iinclude : indiquer o√π sont les headers
  - -o : nom du fichier de sortie
  
- Makefile ou CMakeLists.txt : Automatiser la compilation
  ‚Üí Makefile : syst√®me classique
  ‚Üí CMake : plus moderne, cross-platform

CHOSES √Ä FAIRE:
---------------
1. Comprendre comment compiler manuellement :
   g++ -std=c++17 -Iinclude src/*.cpp -o snake -lsfml-graphics -lsfml-window -lsfml-system

2. (Optionnel) Cr√©er un Makefile ou CMakeLists.txt pour automatiser

RESSOURCES √Ä CHERCHER:
----------------------
- "C++ compilation tutorial"
- "Makefile tutorial"
- "CMake tutorial"
- "SFML compilation"

================================================================================
8. ORDRE D'APPRENTISSAGE RECOMMAND√â
================================================================================

1. COMMENCE PAR : utils.h
   ‚Üí Simple, juste des constantes
   ‚Üí Apprends #pragma once, constexpr, namespace

2. ENSUITE : food.h / food.cpp
   ‚Üí Relativement simple (juste position al√©atoire)
   ‚Üí Apprends random, getters, const

3. PUIS : snake.h / snake.cpp
   ‚Üí Plus complexe (logique du jeu)
   ‚Üí Apprends vector, enum class, collisions

4. ENFIN : game.h / game.cpp
   ‚Üí Le plus complexe (orchestration)
   ‚Üí Apprends unique_ptr, boucle de jeu, SFML

5. TERMINE : main.cpp
   ‚Üí Tr√®s simple, juste le point d'entr√©e

================================================================================
9. CONSEILS G√âN√âRAUX
================================================================================

- TESTE CHAQUE √âTAPE : Ne code pas tout d'un coup, teste au fur et √† mesure
- COMPILE SOUVENT : V√©rifie que √ßa compile apr√®s chaque changement
- LIS LES ERREURS : Les messages d'erreur du compilateur sont tes amis
- CHERCHE : Si tu ne comprends pas un concept, cherche sur internet
- EXP√âRIMENTE : Modifie le code pour voir ce qui se passe
- COMMENCE SIMPLE : Fais fonctionner une version basique, puis am√©liore

================================================================================
10. AM√âLIORATIONS FUTURES (apr√®s avoir fini la base)
================================================================================

- Syst√®me de score
- Menu de d√©marrage
- Game Over screen avec possibilit√© de recommencer
- Vitesse qui augmente avec le score
- Meilleur affichage (textures, animations)
- Sons et musique
- High score sauvegard√©

================================================================================

BON COURAGE ! üêç
N'h√©site pas √† chercher chaque concept que tu ne comprends pas.
L'apprentissage se fait en exp√©rimentant et en faisant des erreurs !

================================================================================
